<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>luaL_Buffer(3type)</title>
</head>
<body>
<table class="head">
  <tr>
    <td class="head-ltitle">luaL_Buffer(3type)</td>
    <td class="head-vol">Lua C API</td>
    <td class="head-rtitle">luaL_Buffer(3type)</td>
  </tr>
</table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">luaL_Buffer</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<p class="Pp"><b>#include &lt;lauxlib.h&gt;</b></p>
<p class="Pp"><b>typedef struct luaL_Buffer luaL_Buffer;</b></p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Type for a <i>string buffer</i> .</p>
<p class="Pp">A string buffer allows false C code to build Lua strings
    piecemeal. Its pattern of use is as follows:</p>
<div class="Bd-indent">
<p class="Pp">First declare a variable <b>b</b> of type <b>luaL_Buffer</b> .</p>
<p class="Pp">Then initialize it with a call <b>luaL_buffinit(L, &amp;b)</b>
  .</p>
<p class="Pp">Then add string pieces to the buffer calling any of the
    <b>luaL_add*</b> functions.</p>
<p class="Pp">Finish by calling <b>luaL_pushresult(&amp;b)</b> . This call
    leaves the final string on the top of the stack.</p>
</div>
<p class="Pp">If you know beforehand the maximum size of the resulting string,
    you can use the buffer like this:</p>
<div class="Bd-indent">
<p class="Pp">First declare a variable <b>b</b> of type <b>luaL_Buffer</b> .</p>
<p class="Pp">Then initialize it and preallocate a space of size <b>sz</b> with
    a call <b>luaL_buffinitsize(L, &amp;b, sz)</b> .</p>
<p class="Pp">Then produce the string into that space.</p>
<p class="Pp">Finish by calling <b>luaL_pushresultsize(&amp;b, sz)</b> , where
    <b>sz</b> is the total size of the resulting string copied into that space
    (which may be less than or equal to the preallocated size).</p>
</div>
<p class="Pp">During its normal operation, a string buffer uses a variable
    number of stack slots. So, while using a buffer, you cannot assume that you
    know where the top of the stack is. You can use the stack between successive
    calls to buffer operations as long as that use is balanced; that is, when
    you call a buffer operation, the stack is at the same level it was
    immediately after the previous buffer operation. (The only exception to this
    rule is <b>luaL_addvalue</b> <b>luaL_pushresult</b> , the stack is back to
    its level when the buffer was initialized, plus the final string on its
  top.</p>
</section>
</div>
<table class="foot">
  <tr>
    <td class="foot-date">November 21, 2024</td>
    <td class="foot-os"></td>
  </tr>
</table>
</body>
</html>
